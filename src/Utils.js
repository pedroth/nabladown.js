//========================================================================================
/*                                                                                      *
 *                                         UTILS                                        *
 *                                                                                      */
//========================================================================================

import { buildDom } from "./buildDom";
import { success, fail } from "./Monads";
import { readFileSync } from "fs";


/**
 * creates a pair pair: (a,b) => pair
 */
export function pair(a, b) {
  return { left: a, right: b };
}

/**
 * creates a stream from a string, string | Array<string> => stream
 */
export function stream(stringOrArray) {
  // copy array or string to array
  const array = [...stringOrArray];
  return {
    head: () => array[0],
    tail: () => stream(array.slice(1)),
    take: (n) => stream(array.slice(n)),
    isEmpty: () => array.length === 0,
    toString: () =>
      array.map(s => (typeof s === "string" ? s : JSON.stringify(s))).join(""),
    filter: predicate => stream(array.filter(predicate)),
    log: () => {
      let s = stream(array);
      while (!s.isEmpty()) {
        console.log(s.head());
        s = s.tail();
      }
    }
  };
}

export function eatNSymbol(n, symbolPredicate) {
  return function (stream) {
    if (n === 0) return success(stream);
    if (symbolPredicate(stream)) {
      return eatNSymbol(n - 1, symbolPredicate)(stream.tail());
    }
    return fail(
      `Caught error while eating ${n} symbols` + stream.toString()
    );
  };
}

export function eatSpaces(tokenStream) {
  return eatSymbolsWhile(tokenStream, s => s.type === " ");
}

export function eatSpacesTabsAndNewLines(tokenStream) {
  return eatSymbolsWhile(tokenStream, s => s.type === " " || s.type === "\t" || s.type === "\n");
}

export function eatSymbolsWhile(tokenStream, predicate) {
  let s = tokenStream;
  while (!tokenStream.isEmpty()) {
    if (!predicate(s.head())) break;
    s = s.tail();
  }
  return s;
}

/**
 *  Select one rule
 * @param  {...any} rules
 */
export function or(...rules) {
  let accError = null;
  for (let i = 0; i < rules.length; i++) {
    try {
      return rules[i]();
    } catch (error) {
      accError = error;
    }
  }
  throw accError;
}

export function mOr(...rules) {
  let failedOrSuccess = fail();
  for (let i = 0; i < rules.length; i++) {
    console.log(">>>", rules[i].toString());
    failedOrSuccess = rules[i]();
    if (failedOrSuccess.isSuccess()) {
      return failedOrSuccess;
    }
  }
  return failedOrSuccess;
}

/**
 * Returns a value based on the predicate
 * @param {*} listOfPredicates
 * @param {*} defaultValue
 */
export function returnOne(listOfPredicates, lazyDefaultValue = createDefaultEl) {
  return input => {
    for (let i = 0; i < listOfPredicates.length; i++) {
      if (listOfPredicates[i].predicate(input))
        return listOfPredicates[i].value(input);
    }
    return lazyDefaultValue(input);
  };
}

export function evalScriptTag(scriptTag) {
  const globalEval = eval;
  const srcUrl = scriptTag?.attributes["src"]?.textContent;
  if (srcUrl) {
    return fetch(srcUrl)
      .then(code => code.text())
      .then(code => {
        globalEval(code);
      });
  } else {
    return new Promise((re) => {
      globalEval(scriptTag.innerText);
      re(true);
    });
  }
}

export async function runLazyAsyncsInOrder(asyncLambdas) {
  for (const asyncLambda of asyncLambdas) {
    await asyncLambda();
  }
}

export function createDefaultEl() {
  const defaultDiv = buildDom("div");
  defaultDiv.inner("This could be a bug!!");
  return defaultDiv;
}

export function measureTime(lambda) {
  const t = performance.now();
  lambda()
  return 1e-3 * (performance.now() - t);
}

export class MultiMap {
  constructor() {
    this.map = {}
  }

  put(key, value) {
    if (!this.map[key]) this.map[key] = [];
    this.map[key].push(value);
  }

  get(key) {
    const value = this.map[key];
    return value
  }
}

/**
 * Generated by ChatGPT
 */
export function isAlpha(str) {
  const charCode = str.charCodeAt(0);
  return (
    (charCode >= 65 && charCode <= 90) || // A-Z
    (charCode >= 97 && charCode <= 122)   // a-z
  );
}

export function isNumeric(str) {
  const charCode = str.charCodeAt(0);
  return (
    (charCode >= 48 && charCode <= 57) // 0-9
  );
}

export function isAlphaNumeric(str) {
  return isAlpha(str) || isNumeric(str);
}


// Generated by google bard, with some custom modifications
export function innerHTMLToInnerText(innerHTML) {
  // Remove all HTML tags from the innerHTML string.
  let innerText = innerHTML.replace(/<[^>]*>/g, '');

  // Replace all HTML entities with their corresponding characters.
  const entities = {
    '&lt;': '<',
    '&gt;': '>',
    '&amp;': '&',
    '&quot;': '"',
    '&apos;': "'",
  };

  for (const entity in entities) {
    innerText = innerText.replace(new RegExp(entity, 'g'), entities[entity]);
  }

  return innerText
    .replaceAll("\n", "")
}

export function fetchResource(resourceName) {
  return fetch(resourceName)
    .then(data => {
      if (!data.ok) throw new Error(`Resource ${resourceName}, not found`);
      return data;
    })
}

export function readResource(resourceName) {
  return success(resourceName)
    .map(
      url => {
        return readFileSync(
          url,
          { encoding: "utf8" }
        )
      }
    )
}

export function tryFetch(...urls) {
  if (urls.length === 0) return Promise.reject("Fetching null resource");
  const [url, ...rest] = urls;
  return fetchResource(url).catch(() => tryFetch(...rest));
}

export function tryRead(...urls) {
  if (urls.length === 0) return fail("Reading null resource");
  const [url, ...rest] = urls;
  return readResource(url).failBind(() => tryRead(...rest));
}